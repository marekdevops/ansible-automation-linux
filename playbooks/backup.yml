---
# Modu≈Ç BACKUP - ZarzƒÖdzanie archiwami i kopiami zapasowymi
# Plik: playbooks/backup.yml
# U≈ºycie: 
#   Archive: ./run-automation.sh backup -e "task_action=archive source=/tomcat target=./backup"
#   Extract: ./run-automation.sh backup -e "task_action=extract source=./tomcat.tar.gz target=/tomcat"

- name: "BACKUP MODULE - ZarzƒÖdzanie archiwami"
  hosts: all
  gather_facts: true
  become: true
  
  vars:
    # Podstawowe zmienne
    backup_action: "{{ task_action | default(action | default('')) }}"
    backup_source: "{{ source | default('') }}"
    backup_target: "{{ target | default('') }}"
    
    # Ustawienia archiwizacji
    tmp_dir: "/tmp"
    min_free_space_gb: "{{ min_space | default(1) }}"  # Minimalne miejsce w GB
    compression_level: "{{ compression | default(6) }}"  # Poziom kompresji (1-9)
    exclude_patterns: "{{ exclude | default('*.log,*.tmp,cache/*') }}"
    
    # Nazwy plik√≥w
    timestamp: "{{ ansible_date_time.epoch }}"
    hostname: "{{ inventory_hostname }}"
    archive_name: "{{ (backup_source | basename) + '_' + hostname + '_' + timestamp + '.tar.gz' }}"
    remote_archive_path: "{{ tmp_dir }}/{{ archive_name }}"
    local_target_path: "{{ backup_target }}/{{ archive_name }}"
    
    # ≈öcie≈ºka bezwzglƒôdna dla extract (wzglƒôdem katalogu, z kt√≥rego uruchamiamy skrypt)
    absolute_source_path: "{{ backup_source if backup_source.startswith('/') else lookup('env', 'PWD') + '/' + backup_source }}"

  pre_tasks:
    - name: "Sprawd≈∫ czy podano akcjƒô"
      fail:
        msg: |
          Musisz podaƒá akcjƒô do wykonania!
          U≈ºyj: ./run-automation.sh backup -e "task_action=archive|extract"
          
          ARCHIVE - Tworzenie kopii zapasowej:
          ./run-automation.sh backup -e "task_action=archive source=/path/to/backup target=./local/backup/dir"
          
          EXTRACT - Przywracanie z kopii:
          ./run-automation.sh backup -e "task_action=extract source=./backup.tar.gz target=/path/to/restore"
      when: backup_action == ""
      tags: always

    - name: "Sprawd≈∫ parametry dla archive"
      fail:
        msg: |
          Dla akcji 'archive' wymagane sƒÖ parametry:
          - source: katalog do zarchiwizowania (na zdalnym serwerze)
          - target: katalog docelowy (na localhost)
          
          Przyk≈Çad: task_action=archive source=/tomcat target=./backup
      when: 
        - backup_action == "archive"
        - (backup_source == "" or backup_target == "")
      tags: always

    - name: "Sprawd≈∫ parametry dla extract"
      fail:
        msg: |
          Dla akcji 'extract' wymagane sƒÖ parametry:
          - source: plik archiwum (na localhost)
          - target: katalog docelowy (na zdalnym serwerze)
          
          Przyk≈Çad: task_action=extract source=./backup/tomcat.tar.gz target=/tomcat
      when: 
        - backup_action == "extract"
        - (backup_source == "" or backup_target == "")
      tags: always

    - name: "Wy≈õwietl informacje o akcji"
      debug:
        msg: |
          === BACKUP MODULE ===
          Akcja: {{ backup_action | upper }}
          {% if backup_action == "archive" %}
          ≈πr√≥d≈Ço (zdalny): {{ backup_source }}
          Cel (lokalny): {{ backup_target }}
          Archiwum: {{ archive_name }}
          {% elif backup_action == "extract" %}
          ≈πr√≥d≈Ço (lokalny): {{ backup_source }}
          Cel (zdalny): {{ backup_target }}
          {% endif %}
          Host: {{ inventory_hostname }}
          Katalog tymczasowy: {{ tmp_dir }}
      tags: always

  tasks:
    # === ARCHIVE TASKS ===
    - block:
        - name: "Sprawd≈∫ czy katalog ≈∫r√≥d≈Çowy istnieje"
          stat:
            path: "{{ backup_source }}"
          register: source_check
          
        - name: "B≈ÇƒÖd - katalog ≈∫r√≥d≈Çowy nie istnieje"
          fail:
            msg: "Katalog ≈∫r√≥d≈Çowy {{ backup_source }} nie istnieje na {{ inventory_hostname }}"
          when: not source_check.stat.exists or not source_check.stat.isdir

        - name: "Sprawd≈∫ rozmiar katalogu ≈∫r√≥d≈Çowego"
          shell: du -sb "{{ backup_source }}" | cut -f1
          register: source_size_bytes
          changed_when: false
          when: not ansible_check_mode

        - name: "Sprawd≈∫ dostƒôpne miejsce w {{ tmp_dir }}"
          shell: df "{{ tmp_dir }}" | tail -1 | awk '{print $4*1024}'
          register: available_space_bytes
          changed_when: false
          when: not ansible_check_mode

        - name: "Ustaw przyk≈Çadowe warto≈õci dla dry-run"
          set_fact:
            source_size_bytes:
              stdout: "1073741824"  # 1GB przyk≈Çadowo
            available_space_bytes:
              stdout: "10737418240"  # 10GB przyk≈Çadowo
          when: ansible_check_mode

        - name: "Oblicz wymagane miejsce (z marginesem 20%)"
          set_fact:
            source_size_gb: "{{ (source_size_bytes.stdout | int / 1024 / 1024 / 1024) | round(2) }}"
            available_space_gb: "{{ (available_space_bytes.stdout | int / 1024 / 1024 / 1024) | round(2) }}"
            required_space_gb: "{{ ((source_size_bytes.stdout | int * 1.2) / 1024 / 1024 / 1024) | round(2) }}"

        - name: "Wy≈õwietl informacje o miejscu"
          debug:
            msg: |
              === ANALIZA MIEJSCA NA DYSKU ===
              Rozmiar ≈∫r√≥d≈Ça: {{ source_size_gb }} GB
              Dostƒôpne miejsce: {{ available_space_gb }} GB
              Wymagane miejsce: {{ required_space_gb }} GB (z marginesem)
              Minimalne wymaganie: {{ min_free_space_gb }} GB

        - name: "Sprawd≈∫ czy wystarczy miejsca"
          fail:
            msg: |
              NiewystarczajƒÖce miejsce na dysku!
              Wymagane: {{ required_space_gb }} GB
              Dostƒôpne: {{ available_space_gb }} GB
              Uwolnij {{ (required_space_gb | float - available_space_gb | float) | round(2) }} GB
          when: available_space_gb | float < required_space_gb | float

        - name: "Utw√≥rz lokalny katalog docelowy"
          file:
            path: "{{ backup_target }}"
            state: directory
            mode: '0755'
          delegate_to: localhost
          become: false

        - name: "Utw√≥rz archiwum tar.gz na zdalnym serwerze"
          shell: |
            cd "{{ backup_source | dirname }}"
            tar -czf "{{ remote_archive_path }}" \
              --exclude-from=<(echo "{{ exclude_patterns.split(',') | join('\n') }}") \
              -C "{{ backup_source | dirname }}" \
              "{{ backup_source | basename }}" \
              2>/dev/null || tar -czf "{{ remote_archive_path }}" \
              -C "{{ backup_source | dirname }}" \
              "{{ backup_source | basename }}"
          register: tar_create_result
          args:
            executable: /bin/bash

        - name: "Sprawd≈∫ czy archiwum zosta≈Ço utworzone"
          stat:
            path: "{{ remote_archive_path }}"
          register: archive_check
          when: not ansible_check_mode

        - name: "B≈ÇƒÖd - nie uda≈Ço siƒô utworzyƒá archiwum"
          fail:
            msg: "Nie uda≈Ço siƒô utworzyƒá archiwum {{ remote_archive_path }}"
          when: 
            - not ansible_check_mode
            - not archive_check.stat.exists

        - name: "Pobierz archiwum na localhost"
          fetch:
            src: "{{ remote_archive_path }}"
            dest: "{{ local_target_path }}"
            flat: yes
          register: fetch_result
          when: not ansible_check_mode

        - name: "Usu≈Ñ tymczasowe archiwum ze zdalnego serwera"
          file:
            path: "{{ remote_archive_path }}"
            state: absent
          when: not ansible_check_mode

        - name: "Sprawd≈∫ rozmiar pobranego archiwum"
          stat:
            path: "{{ local_target_path }}"
          register: local_archive_stat
          delegate_to: localhost
          become: false
          when: not ansible_check_mode

        - name: "Wy≈õwietl podsumowanie archiwizacji"
          debug:
            msg: |
              === ARCHIWIZACJA {{ 'SYMULOWANA (DRY-RUN)' if ansible_check_mode else 'ZAKO≈ÉCZONA' }} ===
              ≈πr√≥d≈Ço: {{ backup_source }} ({{ source_size_gb | default('N/A') }} GB)
              Archiwum: {{ local_target_path }}
              {% if not ansible_check_mode and local_archive_stat is defined %}
              Rozmiar archiwum: {{ (local_archive_stat.stat.size / 1024 / 1024) | round(2) }} MB
              Kompresja: {{ ((1 - (local_archive_stat.stat.size | float / source_size_bytes.stdout | int)) * 100) | round(1) }}%
              {% else %}
              Rozmiar archiwum: Bƒôdzie obliczony po utworzeniu
              {% endif %}
              Status: {{ 'üîç Dry-run' if ansible_check_mode else '‚úÖ Sukces' }}

      when: backup_action == "archive"
      tags: 
        - backup
        - archive

    # === EXTRACT TASKS ===
    - block:
        - name: "Sprawd≈∫ czy plik archiwum istnieje lokalnie"
          local_action:
            module: stat
            path: "{{ absolute_source_path }}"
          register: archive_file_check
          become: false

        - name: "B≈ÇƒÖd - plik archiwum nie istnieje"
          fail:
            msg: "Plik archiwum {{ backup_source }} nie istnieje na localhost (sprawdzano: {{ absolute_source_path }})"
          when: not archive_file_check.stat.exists

        - name: "Utw√≥rz katalog docelowy na zdalnym serwerze"
          file:
            path: "{{ backup_target }}"
            state: directory
            mode: '0755'
            owner: root
            group: root

        - name: "Wygeneruj nazwƒô tymczasowego pliku"
          set_fact:
            temp_archive_name: "restore_{{ ansible_date_time.epoch }}_{{ backup_source | basename }}"
            temp_archive_path: "{{ tmp_dir }}/restore_{{ ansible_date_time.epoch }}_{{ backup_source | basename }}"

        - name: "Skopiuj archiwum na zdalny serwer"
          copy:
            src: "{{ absolute_source_path }}"
            dest: "{{ temp_archive_path }}"
            mode: '0644'
          register: copy_result

        - name: "Sprawd≈∫ zawarto≈õƒá archiwum"
          shell: tar -tzf "{{ temp_archive_path }}" | head -20
          register: archive_contents
          changed_when: false
          when: not ansible_check_mode

        - name: "Wy≈õwietl zawarto≈õƒá archiwum"
          debug:
            msg: |
              === ZAWARTO≈öƒÜ ARCHIWUM ===
              {{ archive_contents.stdout if not ansible_check_mode else 'Zawarto≈õƒá bƒôdzie sprawdzona po skopiowaniu archiwum' }}
              {% if not ansible_check_mode and archive_contents.stdout_lines | length == 20 %}
              ... (i wiƒôcej plik√≥w)
              {% endif %}

        - name: "Sprawd≈∫ dostƒôpne miejsce dla ekstraktowania"
          shell: df "{{ backup_target }}" | tail -1 | awk '{print $4*1024}'
          register: extract_available_space
          changed_when: false
          when: not ansible_check_mode

        - name: "Ustaw przyk≈Çadowe warto≈õci dla extract dry-run"
          set_fact:
            extract_available_space:
              stdout: "10737418240"  # 10GB przyk≈Çadowo
          when: ansible_check_mode

        - name: "Rozpakuj archiwum"
          shell: |
            cd "{{ backup_target }}"
            tar -xzf "{{ temp_archive_path }}" --strip-components=1
          register: extract_result
          when: not ansible_check_mode

        - name: "Usu≈Ñ tymczasowe archiwum"
          file:
            path: "{{ temp_archive_path }}"
            state: absent
          when: not ansible_check_mode

        - name: "Sprawd≈∫ wyniki ekstraktowania"
          find:
            paths: "{{ backup_target }}"
            file_type: any
          register: extracted_files
          when: not ansible_check_mode

        - name: "Ustaw przyk≈Çadowe warto≈õci extracted_files dla dry-run"
          set_fact:
            extracted_files:
              matched: 42
          when: ansible_check_mode

        - name: "Wy≈õwietl podsumowanie ekstraktowania"
          debug:
            msg: |
              === EKSTRAKTOWANIE ZAKO≈ÉCZONE ===
              Archiwum: {{ backup_source }}
              Cel: {{ backup_target }}
              Wyekstraktowano: {{ extracted_files.matched }} plik√≥w/katalog√≥w
              Dostƒôpne miejsce: {{ (extract_available_space.stdout | int / 1024 / 1024 / 1024) | round(2) }} GB
              Status: ‚úÖ Sukces

      when: backup_action == "extract"
      tags:
        - backup
        - extract

    # === PODSUMOWANIE ===
    - name: "Wy≈õwietl instrukcje"
      debug:
        msg: |
          === INSTRUKCJE BACKUP MODULE ===
          
          üì¶ TWORZENIE KOPII ZAPASOWEJ (ARCHIVE):
          ./run-automation.sh backup -e "task_action=archive source=/path/to/backup target=./backup"
          
          üìÇ PRZYWRACANIE Z KOPII (EXTRACT):
          ./run-automation.sh backup -e "task_action=extract source=./backup/file.tar.gz target=/path/to/restore"
          
          üîß DODATKOWE OPCJE:
          - min_space=2: Minimalne miejsce w GB (domy≈õlnie 1)
          - compression=9: Poziom kompresji 1-9 (domy≈õlnie 6)
          - exclude="*.log,*.tmp": Wzorce wyklucze≈Ñ
          
          üìã PRZYK≈ÅADY:
          # Kopia Tomcat
          ./run-automation.sh backup -e "task_action=archive source=/opt/tomcat target=./backups"
          
          # Przywr√≥ƒá Tomcat
          ./run-automation.sh backup -e "task_action=extract source=./backups/tomcat_server1_123456.tar.gz target=/opt/tomcat"
          
          # Z wykluczeniami
          ./run-automation.sh backup -e "task_action=archive source=/var/www exclude='*.log,cache/*,*.tmp' target=./www-backup"
      tags: backup